Одна горутина не может принудительно остановить другую.
Чтобы сделать goroutine остановливаемой, ей можно позволить слушать сигнал остановки на канале.

quit := make(chan struct{})
go func() {
    for {
        select {
        case <-quit:
            return
        default:
            // …
        }
    }
}()
// …
close(quit)

Иногда удобно использовать один канал для передачи данных и сигнализации.

// Generator возвращает канал, 
// который производит числа 1, 2, 3,…
// Чтобы остановить подлежащую goroutine, закройте канал.
func Generator() chan int {
    ch := make(chan int)
    go func() {
        n := 1
        for {
            select {
            case ch <- n:
                n++
            case <-ch:
                return
            }
        }
    }()
    return ch
}

func main() {
    number := Generator()
    fmt.Println(<-number)
    fmt.Println(<-number)
    close(number)
    // …
}
